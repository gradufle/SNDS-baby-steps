
/*********activité hospitalière, virus et affections respiratoires ********/


/*%do loop = &start %to &end;*/

/* librairie */
%let Fichiers=%sysget(HOME)/sasdata;

%let annee = 2020; /* Param tre   indiquer : ann e sur laquelle on veut calculer les taux Transfert */
%let anneem1 = %eval(&annee-1 );
%let anneep1 = %eval(&annee+1 );
%let an = %substr(&annee,3,2);
%let anp1 = %substr(&anneep1,3,2); /* table infra annuelle */

/*liste des finessgeo en doublons avant 2018*/
%let AP = ('130780521', '130783236', '130783293', '130784234', '130804297','130784259',
'600100101', '750041543', '750100018', '750100042', '750100075', '750100083',
'750100091', '750100109', '750100125', '750100166', '750100208', '750100216',
'750100232', '750100273', '750100299', '750801441', '750803447', '750803454',
'910100015', '910100023', '920100013', '920100021', '920100039', '920100047',
'920100054', '920100062', '930100011', '930100037', '930100045', '940100027',
'940100035', '940100043', '940100050', '940100068', '950100016', '690783154',
'690784137', '690784152', '690784178', '690787478', '830100558');

/* Les affections de l'appareil respiratoire se trouvent en CMD 04 */



proc sql;
create table sasdata1.RespBase_2020 as
select a.ETA_NUM, a.RSA_NUM, a.NIR_ANO_17,
b.AGE_ANN, b.COD_SEX, b.GHS_NUM, b.GRG_GHM, substr(b.GRG_GHM,1,2) as CMD, 
substr(b.GRG_GHM,6,1) as GRAV, a.EXE_SOI_DTD, a.EXE_SOI_DTF
from ORAVUE.T_MCO20C a
left join ORAVUE.T_MCO20B b 
on a.ETA_NUM = b.ETA_NUM  and a.RSA_NUM = b.RSA_NUM;
quit;



data sasdata1.RespBase_2020; 
set sasdata1.RespBase_2020;
/*if CMD='04';*/
LOS=(EXE_SOI_DTF-EXE_SOI_DTD)/86400;
run;

/* Questionement sur l'occupancy d'une unité médicale */

/* Nécessite :
1) une concatenation entre la base T_MCO20C et T_MCO20UM, sur la base de RSA_NUM et ETA_NUM 
2) le calcul de la date d'arrivée dans l'UM:
	- Ordoné par RUM_ORD_NUM
	- première UM: DATE_E=EXE_SOI_DTD 
	- nième UM : DATE_E = DATE_E + PAR_DUR_SEJ
	- test: pour dernier UM : DATE_E = EXE_SOI_DTF
3) obtenir une table avec l'um et son nombre de patient par jour 
	- Créer un vecteur de date 365 jours : "day"
	- Si Date_E>=day>=Date_S alors incrementer NbPat pour l'um 
4) Agréger au niveau de l'autorisation médicale

*/

/* 1) Concaténation entre T_MCO20C et T_MCO20UM sur RSA_NUM et ETA_NUM */
proc sql;
create table WORK.MCO20 as select 
	C.*, U.NUM_ANO_UM, 
	U.AUT_TYP1_UM, 
	U.RUM_ORD_NUM,
	U.PAR_DUR_SEJ
    from sasdata1.RespBase_2020 as C
    inner join ORAVUE.T_MCO20UM as U
        on C.RSA_NUM = U.RSA_NUM
       and C.ETA_NUM  = U.ETA_NUM
    order by C.RSA_NUM, C.ETA_NUM, U.RUM_ORD_NUM;
quit;


/*= U.RSA_NUM
       and C.ETA_NUM  = U.ETA_NUM
    order by C.RSA_NUM, C.ETA_NUM, U.RUM_ORD_NUM;
quit;

/* Assurer l'ordre */
proc sort data=WORK.MCO20 nodupkey;
  by ETA_NUM RSA_NUM RUM_ORD_NUM;
run;

/* 2) Calcul de la date d'arrivée dans l'UM (DATE_E) */
data WORK.MCO20_DATEE;
    set WORK.MCO20;
    by ETA_NUM RSA_NUM RUM_ORD_NUM;
    retain DATE_E;

    /* Première UM : DATE_E = EXE_SOI_DTD */
    if first.ETA_NUM then DATE_E = EXE_SOI_DTD;
    else DATE_E = lag(DATE_E) + (lag(PAR_DUR_SEJ)*86400);

    format DATE_E datetime20.;
run;

/* Calcul itératif de DATE_E en datetime */
data WORK.MCO20_DATEE;
  set WORK.MCO20;
  by ETA_NUM RSA_NUM RUM_ORD_NUM;

  /* variables de rétention pour l'itération */
  retain prev_date_e prev_par_dur;
  format prev_date_e datetime20.;
  format DATE_E datetime20.;
  format DATE_S datetime20.;
  /* si nouvelle hospitalisation (nouvel ETA_NUM) : starter */
	  if first.ETA_NUM or first.RSA_NUM then do;
	      DATE_E = EXE_SOI_DTD;
		  DATE_S = DATE_E + PAR_DUR_SEJ * 24 * 60 * 60;
		if missing(PAR_DUR_SEJ) then do;
		  DATE_S = EXE_SOI_DTF;
		end;
	  end;
	  else do;
	    /* sécurité : si prev_par_dur manquant -> 0 */
	    if missing(prev_par_dur) then prev_par_dur = 0;
	    /* prev_par_dur est en jours -> convertir en secondes */
	    DATE_E = prev_date_e + prev_par_dur * 24 * 60 * 60;
		DATE_S = DATE_E + PAR_DUR_SEJ * 24 * 60 * 60;
	  end;
  /* mettre à jour les valeurs "précédentes" pour la prochaine itération */
  prev_date_e  = DATE_E;
  prev_par_dur = PAR_DUR_SEJ;
run;

/* 3) obtenir une table avec l'um et son nombre de patient par jour*/

/* 3.1. Génération du vecteur des jours de l’année 2020 */
data WORK.CALENDAR_2020;
    format DATE date9.;
    do DATE = '01JAN2020'd to '31DEC2020'd;
        output;
    end;
run;

/* 3.2. Transformation des datetime en date (pour comparaison plus simple) */
data WORK.MCO20_DATEE_JOUR;
    set WORK.MCO20_DATEE;
    format DATE_E_J DATE_S_J date9.;
    DATE_E_J = datepart(DATE_E);
    DATE_S_J = datepart(DATE_S);
    keep ETA_NUM NUM_ANO_UM AUT_TYP1_UM NIR_ANO_17 RSA_NUM GRG_GHM RUM_ORD_NUM AGE_ANN COD_SEX LOS
	DATE_E_J DATE_S_J;
run;

/* 3.3. Expension des dates pour obtenir les jours de présence des patients*/

data WORK.OCCUPANCY_RAW;
    set WORK.MCO20_DATEE_JOUR;
	format DATE date9.;
    do DATE = DATE_E_J to DATE_S_J;
        output;
    end;
run;

/* 3.4. Comptage du nombre de patients présents par UM et par jour */
proc sql;
    create table WORK.OCCUPANCY_UM as
    select 
        ETA_NUM,
        NUM_ANO_UM,
        DATE,
        count(distinct RSA_NUM) as NB_PAT
    from WORK.OCCUPANCY_RAW_A
    group by ETA_NUM, NUM_ANO_UM, DATE
    order by ETA_NUM, NUM_ANO_UM, DATE;
quit;


proc sort data=WORK.OCCUPANCY_RAW nodupkey;
  by ETA_NUM RSA_NUM DATE;
run;

/* 3.4. Liste complète des combinaisons UM x jour */
proc sql;
    create table WORK.UM_CALENDAR as
    select distinct 
        M.ETA_NUM,
        M.NUM_ANO_UM,
        C.DATE
    from ORAVUE.T_MCO20SUP_IUM as M,
         WORK.CALENDAR_2020 as C;
quit;

/* 3.4b. Liste pour xgboost */

proc sql;
    create table WORK.OCCUPANCY_XG as
    select 
        UC.ETA_NUM,
        UC.NUM_ANO_UM,
        UC.DATE
	from WORK.UM_CALENDAR as UC
    left join (
        select 
		ETA_NUM, NUM_ANO_UM, AUT_TYP1_UM, NIR_ANO_17, RSA_NUM, DATE, GRG_GHM, RUM_ORD_NUM
        from WORK.OCCUPANCY_RAW
    ) as O
    on UC.ETA_NUM = O.ETA_NUM
   and UC.NUM_ANO_UM = O.NUM_ANO_UM
   and UC.DATE = O.DATE
    order by ETA_NUM, NUM_ANO_UM, DATE;
quit;


/* 3.5. Comptage du nombre de patients présents, puis jointure pour remplir les zéros */
proc sql;
    create table WORK.OCCUPANCY_UM as
    select 
        UC.ETA_NUM,
        UC.NUM_ANO_UM,
        UC.DATE,
        coalesce(O.NB_PAT, 0) as NB_PAT
	from WORK.UM_CALENDAR as UC
    left join (
        select 
            ETA_NUM,
            NUM_ANO_UM,
            DATE,
            count(distinct RSA_NUM) as NB_PAT
        from WORK.OCCUPANCY_RAW
        group by ETA_NUM, NUM_ANO_UM, DATE
    ) as O
    on UC.ETA_NUM = O.ETA_NUM
   and UC.NUM_ANO_UM = O.NUM_ANO_UM
   and UC.DATE = O.DATE
    order by ETA_NUM, NUM_ANO_UM, DATE;
quit;


proc sql;
create table WORK.T_MCO20B2 as
select *,
sum(missing(DGN_PAL)) as Diag_Miss
from ORAVUE.T_MCO20B;
quit;



